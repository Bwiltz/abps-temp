/* eslint-env browser, jquery */
import * as most from 'most';
import { bus } from 'partybus';
import R from 'ramda';

const progress_store = (sections = []) => {
  let progress = sections.filter( item => (item.hidden !== true) );
  console.log("incoming sections to cache:",sections);
  window.progress_cache = progress.length ? progress : window.progress_cache;
  bus.emit('activity::progress::updated', window.progress_cache);
};

const mark_complete = (i) => i.completed = true;

const update_progress = (slug) => {
  console.log("update_progress",slug);
  const new_progress = window.progress_cache.map(item => {
    if (item.slug === slug && item.completion === 'visited') {
      mark_complete(item);
    }
    return item;
  });
  progress_store(new_progress);
};

const update_up_to_progress = (slug) => {
  console.log("update_up_to_progress()",slug);
  let reached = false;
  const new_progress = window.progress_cache.map(item => {
    if (reached) {
      return item;
    }
    mark_complete(item);
    if (item.slug === slug) {
      reached = true;
    }
    return item;
  });
  progress_store(new_progress);
};

const complete_one_section = (slug) => {
  console.log("complete_one_section()",slug);
  const new_progress = window.progress_cache.map(item => {
    if (item.slug === slug) {
      mark_complete(item);
    }
    return item;
  });
  progress_store(new_progress);
};

const remove_section_not_found = (slug) => {
  window.progress_cache = window.progress_cache.filter((i) => { i.slug !== slug });
};

bus.on('hucklebucked', update_progress);
// bus.on('tincan::bookmark::found', update_up_to_progress);
bus.on('activity::progress::complete', complete_one_section);
bus.on('activity::progress::setup', progress_store);
bus.on('tincan::sections::restore', progress_store);

bus.on('section::failed_to_load', remove_section_not_found);


export default null;